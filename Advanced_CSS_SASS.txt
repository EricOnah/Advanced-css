h1A crash course for CSS and SASS. (Based on a project)

Basic Starter CSS setup: This will reset the default browser setting of your page onload

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

// This will reset the default browser setting for margin and padding
//For box-sizing: border-box; This means the paddings and margins will not be 
added to the defined size of the box element


    body {
        font-family:"Lato", sans-serif; ;
        font-weight: 400;
        line-height: 1.7;
        padding: 30px;
        color: #777;
    }

//The above sets your preferred style for the body element which is inherited by all the child elements if no 
other style is defined for the element. NOTE: Padding is not inherited by all the child elements.

NOTE: For this project we are using the BEM - BEM (Block, Element, Modifier) is a component-based approach to web development. The idea behind it is to divide the user interface into independent blocks. This makes interface development easy and fast even with a complex UI, 
     and it allows reuse of existing code without copying and pasting.
     to learn about this method visit - https://en.bem.info/methodology/quick-start/


Building the header:

    .header {
        height: 95vh;
        background-image: linear-gradient(to right bottom, 
        rgba(255, 255, 255, 0.8), 
        rgba(0, 0, 0, 0.8)),
        url(../img/bg.jpg);
        background-size: cover;
        background-position: top;

        clip-path: polygon(0 0, 100% 0, 100% 75%, 0 100%);
        position: relative;
    }

//The above defines the style of the header. Without a defined width, it assumes the width of the container.
//Tha background image features a color gradient overlayed on the background image.
//With background-size set to cover, the image adjust without losing pixels to fit the container.
//background-position: top; The image is adjusted to show more of the top side of the image.
//The clip-path property is used to clip images in a specific way. 
//The polygon we use has four sides(x y, x y, x y, x y) The x and y represents axis. So we set the starting point of the polygon
//to 0 0(no movement), te next side in a clockwise direction we set the x to 100% because we need the image to
//go 100% in the x direction from the starting point to the second side of the polygon and y to zero.
//for the 3rd side we set the x to 100% as well and the y to 75% because we want the image to be clip at this point.
//the 4th side the x is set to zero and the y to 100% from origin.

NOTE: for clip-path resources visit: https://bennettfeely.com/clippy/

hmtl structure for the logo: Since image is an inline element, it's better to wrap the img with a div.

    <div class="logo-box">
        <img src="#" alt="logo" class="logo">
    </div>

//This will make the styling easy.

styling The logo:

position: To use this the parent element of the box should have it's position relative so tha the positions
defined for the box will be in relation to the parent element.

With the logo-box we set the position of the logo in the header and with class logo, we define the size of the logo.

    .header__logo-box {
        position: absolute;
        top: 40px;
        left: 40px;
    }

    .header__logo {
        height: 35px;
    }

//You can always play with these numbers

Heading: For SEO pupose, the h1 is the most important heading. So it is used to define the heading of the web page.
for this project, we split the heading into two using a span element for styling purposes.
    <div class="text-box">
        <h1 class="heading-primary>
            <span class="heading-primary-main">The main title</span>
            <span class="heading-primary-sub">The sub-main title</span>
        </h1>
    </div>
   

Styling the heading: The heading-primary class will style the whole heading while the span classes will style the
individual parts of the heading.

    .heading-primary {
        color: #;
        text-transform: uppercase;
    }

To have the individual parts of the heading occupying separate line we give the display property block.

    .heading-primary-main {
        display: block;
        font-size: ;
        font-weight: ;
        letter-spacing: ;
    }

    .heading-primary-sub {
        display: block;
        font-size: ;
        font-weight: ;
        letter-spacing: ;
    }

To position the heading in the center, we style the text-box.

    .header__text-box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

The above style in the text-box is how to center an element in the parent container using positioning.

//We styled the box after styling the heading text but the box style should be put above the heading style to follow
//the html order.

NOTE: Always wrap parts of a section to be styled separately in a div.

Adding animation to the heading text: Using @keyframes we can add animation to a css element.

    @keyframes moveInLeft {
        0% {
            opacity: 0;
            transform: translateX(-100px);
        }

        80% {
            transform: translateX(20px); 
        }

        100% {
           opacity: 1;
            transform: translateX(0); 
        }
    }

We define the % to be a point in the animation time. You can whatever point from 0 - 100. To apply this animation to a css element
we add the animation property to it's styling. animation: <animation name> <animation duration> <animation timing fxn>
Since we are animating the heading text we add this animation property to the heading text.

NOTE: Browser is optmized for opacity and transform property.
NOTE: The 80% point is added for bouncing effect. The over moves at 80% and returns to 0 at 100%.

    .heading-primary-main {
        display: block;
        font-size: ;
        font-weight: ;
        letter-spacing: ;
        animation: moveInLeft .2s ease-in;
    } 

For the sub heading we can dd a moveInRight animation to show a movement in the opposite direction.
to do this, we define properties that are exact opposite to the the moveInLeft animation.


    .heading-primary-sub {
            display: block;
            font-size: ;
            font-weight: ;
            letter-spacing: ;
            animation: moveInRight .2s ease-out;
            
        }

//to fix the shake in the animation we use a property backface-visibility and set it to hidden. This is added
the heading itself

      .heading-primary {
        color: #;
        text-transform: uppercase;
        backface-visibility: hidden;
    }


//for more animations visit: https://animista.net/

Adding the search button:  Since the search button is right below the heading we can have it in the same box as the heading.


    <div class="text-box">
        <h1 class="heading-primary>
            <span class="heading-primary-main">The main title</span>
            <span class="heading-primary-sub">The sub-main title</span>
        </h1>

        <a href="#" class="btn btn-primary">Your preferred text</a>
    </div>

You can do this with both a link or button or both combined but for easy styling we used the link.

Styling the search button:

    .btn:link,
    .btn:visited {
        text-decoration: none;
        text-transform: uppercase;
        display: inline-block;
        padding: 15px 40px;
        border-radius: 100px;
        transition: all .2s;
        position: relative;
    }


    .btn-primary {
        background-color: #;
        color: #;
    }


//In order to have the paddings and margins behave properly when applied to an inline element,
//we change the display property to inline-block.
//the .btn is a general class for all our button in this page to make the styling less voluminous.
//we the used the .btn-primary or any other name to mean specific buttons and give them their specific styling.
//transition property is always added in the initial state not where the transform is defined.

To have the button in the center of the container, we add text-align property to the container since it's an inline element.

    .text-box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
    }

To add animation to the button we can choose to add it to the hover pseudo class.

    .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0(<x-direction>) 10px(<y-direction>) 20px(<blur>) rgba(0, 0, 0, 0.5); //rgba to add transparency to the color
    }

    .btn:active {
         transform: translateY(-1px);
    }
//This will add a bounce effect to the button on hover and click events.

Adding the ::after pseudo element to animate the button a give it a blink effect. with this we can create an
element just like the parent element the button with just css.

.btn::after {
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 100px;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all .2s;
}

.btn-primary::after {
    background-color: #;

}


//The content property is very important for the after pseudo element to appear on the page.
//To position the after pseudo element behind the parent element we use the absolute positioning with the btn
//as the parent element set to position relative.

Now that we have the after pseudo element, we can animate it on hover

    btn:hover::after {
        transform: scaleX(1.4) scaleY(1.6);
        opacity: 0;
    }

//The opacity 0 is added for a fade-out effect.

we can always add an animation on load just like the headings.

    @keyframes moveInBtn {

        0%{
            transform: translateY(30px);
            opacity: 0;
        }

        100% {
            opacity: 1;
            transform: translateY(0)
        }
        
    }

//To have this animation apply to chosen button, we can add an extra class to the element say .btn-animated

    .btn-animated {
        animation: moveInBtn 0.2s easeIn 0.75(<animation delay>);
        animation-fill-mode: backwards;
    }

//animation-fill-mode: backwards we start the animation on load from 0%. This way the button doesn't appear first before animating.


Using Sass:

First we install node-sass as our compiler. To do that we use `npm install node-sass --save-dev`

//--save-dev will add the node-sass as a developer dependency in our package.json file.
//NOTE: You must have node.js installed before this.

create a folder for the sass files and in the folder create the main.scss file.
//we will be using scss for our sass in this project.

In the package.json file add a compiler script that we compile our sass codes in the style.css file

Under scripts add - `"compile:sass:" "sass/main.scss css/style.css -w"

//The -w will make Node.js to watch for changes in our files and compile on save

This way scss code we write in our sass files will be automatically compiled by node.js.

NOTE: We will be creating files and folders to house different aspect of our styling using the - 7 in 1 pattern

Sass we can nest codes using `&` to make it make more sense. This way keep maintaining the BEM method.

e.g .header {
        height: 95vh;
        background-image: linear-gradient(to right bottom, 
        rgba(255, 255, 255, 0.8), 
        rgba(0, 0, 0, 0.8)),
        url(../img/bg.jpg);
        background-size: cover;
        background-position: top;

        clip-path: polygon(0 0, 100% 0, 100% 75%, 0 100%);
        position: relative;

        &__logo {

        }

        &__text-box {

        }

    }


NOTE: You can do this with blocks and elements and it's modifiers.

//This way we can have all the styling for the header and child elements in one giant code block.
//'&' is used to nest a selector/pseudo selector inside parent selector. Once the '&" is used, it means
//the selector where the nesting is happening is carried into the selector name where th '&" appeared.
//as in the above '&__logo" means .header__logo
    
Creating the folders: This folders will contain partials so that they can be imported in the main.scss. The filename for
partials starts with `_`
    1. bass: - For low level bases such as reset, html, body elements - _base.scss
        files for base folder: _base.scss, _animation.scss, _typography.scss, _utilities.scss
    2. abstract: - for _variables.scss, _mixins.scss, _functions.scss

    3. Components: reuseable components are stored here. 

    4. Layout: Here we have the global header, footer etc

    5. Pages: for specific pages.

    6. Themes:

    7: Vendors: 

NOTE: With @import we import this partials in the main.scss file `@import base/base`  The <foldername>/<file name>
//The `_` in the scss file name is omitted from the @import line. Sass will automatically know it's partial. 
//for each file created, you must import it in the main.scss file for to be recognized.

Next is to move the codes to each specific file. Animation in _animation.scss, typography in _typography.scss

Building grid system:

First create a row and put the columns inside the row.

    <div class="row">
        <div class="col-1-of-2">
            1st half of two equal columns
        </div> 
        <div class="col-1-of-2">
            2nd half of two equal columns
        </div>
    </div>

//A row containing two equal columnsof equal halves

    <div class="row">
        <div class="col-1-of-3">
            1st part of 3 equal columns
        </div> 
        <div class="col-1-of-3">
            2nd part of 3 equal columns
        </div> 
        <div class="col-1-of-3">
            3rd part of 3 equal columns
        </div>
    </div>

//A row containing 3 equal columns of equal parts

<div class="row">
        <div class="col-1-of-3">
            1st part of 3 equal columns
        </div> 
        <div class="col-2-of-3">
            2nd stretching through 2 equal equal columns
        </div> 
    </div>

//A row containing 2 columns witch 1 stretching through 2 parts

<div class="row">
        <div class="col-1-of-4">
            1st part of 4 equal columns
        </div> 
        <div class="col-1-of-4">
            2nd part of 4 equal columns
        </div> 
        <div class="col-1-of-4">
            3rd part of 4 equal columns
        </div> 
        <div class="col-1-of-4">
            4th part of 4 equal columns
        </div>
    </div>
    
    <div class="row">
        <div class="col-1-of-4">
            1st part of 4 equal columns
        </div> 
        <div class="col-1-of-4">
            2nd part 
        </div> 
        <div class="col-2-of-4">
            3rd part 
        </div> 
    </div> 
    
    <div class="row">
        <div class="col-1-of-4">
            1st part 
        </div> 
        <div class="col-3-of-4">
            2nd part
        </div>  
    </div>

    //from the class name you will see how much of space each column occupies in the row.

Styling: This is layout so it goes into the layout folder. _grid.scss

    .row {
        margin: 0 auto;
        max-width: $grid-width;

        &not(:last-child) {
            margin-bottom: $gutter-vertical;
        }
        
    }

//In the typography, define the custom font size for the html in rem. Default browser font size is 16px,
//we can set 1 rem to be 10 px by making font-size: 62%; for html.
//create variables in the variables file to represent the margins for the row.
//since we don't want margin-bottom on the last child of the row we use the not() pseudo class.
//in the above, it means every other child except the last child.


Now we can style the columns:

width of the column = 100% of the width of the row minus the horizontal gutter divided by the number of columns in that row.
If there are columns occupying more than one column space by the division, the column space will be = column
space times number of columns in that row the column is going to occupy.

e.g  .row {
        margin: 0 auto;
        max-width: $grid-width;

        &not(:last-child) {
            margin-bottom: $gutter-vertical;
        }
        
    

        .col-of-2 {
            width: calc((100% - #{$gutter-horizontal}) / 2);
            background-color: #;
            float: left;

            &:not(:last-child){
                margin-right: $gutter-horizontal;
            }
        }
    }

//When you float element, the height collapses and becomes zero. To correct this, we use the clearfix method.
//This appends a pseudo element after the element that clears this error.

In the _mixins.scss we write rhe clearfix method and add include it where appropriate.
NOTE: You can write a mixin for codes that you use repeatedly and have them included wherever needed.

    @mixin clearfix {
        &::after {
            content: "";
            display: table;
            clear: both;
        }
    }

//You must include the content property or the pseudo element will not show.
//This display property for this always table
//the clear property is what does the actual work and set to both it will clear both left and right float

Now can include it in the grid inside the row.

.row {
        margin: 0 auto;
        max-width: $grid-width;

        &not(:last-child) {
            margin-bottom: $gutter-vertical;
        }
        
        @include clearfix;

        .col-of-2 {
            width: calc((100% - #{$gutter-horizontal}) / 2);
            background-color: #;
            float: left;

            &:not(:last-child){
                margin-right: $gutter-horizontal;
            }
        }
    }